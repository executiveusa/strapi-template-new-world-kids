import { getTemplate, validateEnvValue, type EnvVariable } from './templates';

export interface EnvEntry {
  key: string;
  value: string;
  comment?: string;
}

export interface GenerateEnvOptions {
  stack?: string | string[];
  overrides?: Record<string, string>;
  includeComments?: boolean;
  includeDefaults?: boolean;
}

export interface GenerateEnvResult {
  content: string;
  variables: EnvEntry[];
  warnings: string[];
  errors: string[];
}

/**
 * Sanitize environment variable key
 */
export function sanitizeKey(key: string): string {
  // Remove whitespace and control characters
  let sanitized = key.trim().replace(/[\s\x00-\x1F\x7F]/g, '');

  // Ensure uppercase with underscores
  sanitized = sanitized.toUpperCase().replace(/[^A-Z0-9_]/g, '_');

  // Ensure it doesn't start with a number
  if (/^\d/.test(sanitized)) {
    sanitized = '_' + sanitized;
  }

  return sanitized;
}

/**
 * Validate environment variable key format
 */
export function isValidKey(key: string): boolean {
  // Must start with letter or underscore, contain only alphanumeric and underscore
  return /^[A-Z_][A-Z0-9_]*$/.test(key);
}

/**
 * Escape value for .env format
 */
export function escapeValue(value: string): string {
  // If value contains special characters, wrap in quotes
  if (/[\s"'$`\\]/.test(value)) {
    return `"${value.replace(/"/g, '\\"')}"`;
  }
  return value;
}

/**
 * Generate .env file content from template and overrides
 */
export function generateEnv(options: GenerateEnvOptions): GenerateEnvResult {
  const warnings: string[] = [];
  const errors: string[] = [];
  const variables: EnvEntry[] = [];
  const seenKeys = new Set<string>();

  // Collect variables from templates
  const stacks = Array.isArray(options.stack) ? options.stack : options.stack ? [options.stack] : [];

  for (const stackName of stacks) {
    const template = getTemplate(stackName);
    if (!template) {
      warnings.push(`Unknown template: ${stackName}`);
      continue;
    }

    for (const variable of template.variables) {
      const key = sanitizeKey(variable.key);

      if (seenKeys.has(key)) {
        continue; // Skip duplicates
      }
      seenKeys.add(key);

      let value = '';

      // Priority: override > default > placeholder
      if (options.overrides && options.overrides[variable.key]) {
        value = options.overrides[variable.key];
      } else if (options.includeDefaults && variable.defaultValue) {
        value = variable.defaultValue;
      } else if (variable.placeholder) {
        value = variable.placeholder;
      }

      // Validate if pattern exists
      if (variable.pattern && value && !validateEnvValue(key, value, variable.pattern)) {
        warnings.push(`Value for ${key} does not match expected pattern`);
      }

      // Check required fields
      if (variable.required && !value && !options.includeDefaults) {
        errors.push(`Missing required variable: ${key}`);
      }

      variables.push({
        key,
        value,
        comment: variable.description,
      });
    }
  }

  // Add custom overrides not in template
  if (options.overrides) {
    for (const [rawKey, value] of Object.entries(options.overrides)) {
      const key = sanitizeKey(rawKey);

      if (!isValidKey(key)) {
        errors.push(`Invalid key format: ${rawKey}`);
        continue;
      }

      if (!seenKeys.has(key)) {
        seenKeys.add(key);
        variables.push({
          key,
          value,
        });
      } else {
        // Update existing variable
        const existing = variables.find(v => v.key === key);
        if (existing) {
          existing.value = value;
        }
      }
    }
  }

  // Build content
  const lines: string[] = [];

  if (options.includeComments) {
    lines.push('# Generated by EnvSmith');
    lines.push(`# Date: ${new Date().toISOString()}`);
    if (stacks.length > 0) {
      lines.push(`# Templates: ${stacks.join(', ')}`);
    }
    lines.push('');
  }

  for (const variable of variables) {
    if (options.includeComments && variable.comment) {
      lines.push(`# ${variable.comment}`);
    }
    lines.push(`${variable.key}=${escapeValue(variable.value)}`);
    if (options.includeComments) {
      lines.push('');
    }
  }

  return {
    content: lines.join('\n'),
    variables,
    warnings,
    errors,
  };
}

/**
 * Parse existing .env content into key-value pairs
 */
export function parseEnv(content: string): Record<string, string> {
  const result: Record<string, string> = {};
  const lines = content.split('\n');

  for (let line of lines) {
    line = line.trim();

    // Skip comments and empty lines
    if (!line || line.startsWith('#')) {
      continue;
    }

    const equalIndex = line.indexOf('=');
    if (equalIndex === -1) {
      continue;
    }

    let key = line.substring(0, equalIndex).trim();
    let value = line.substring(equalIndex + 1).trim();

    // Remove quotes if present
    if ((value.startsWith('"') && value.endsWith('"')) ||
        (value.startsWith("'") && value.endsWith("'"))) {
      value = value.slice(1, -1);
    }

    result[key] = value;
  }

  return result;
}

/**
 * Merge multiple .env contents, with later entries overriding earlier ones
 */
export function mergeEnv(...contents: string[]): string {
  const merged: Record<string, string> = {};

  for (const content of contents) {
    const parsed = parseEnv(content);
    Object.assign(merged, parsed);
  }

  return generateEnv({
    overrides: merged,
    includeComments: false,
  }).content;
}

/**
 * Generate .env files for different environments
 */
export function generateEnvByEnvironment(
  options: GenerateEnvOptions
): Record<string, string> {
  const base = generateEnv({
    ...options,
    includeComments: true,
  });

  return {
    '.env': base.content,
    '.env.development': base.content,
    '.env.production': base.content.replace(/development/g, 'production'),
  };
}
